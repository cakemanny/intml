#!/bin/bash

intml=../../intml
# add a main function to make codegen happy
end=" let main () = 0"
red=$(tput setaf 1)
green=$(tput setaf 2)
reset=$(tput sgr0)

failures=0

expect_fail() {
    code=$1
    if (echo "$code$end" | $intml -t -o /dev/null - >/dev/null 2>&1); then
        echo "${red}fail:${reset} compiled without error: $code"
        failures=$(($failures + 1))
    else
        echo "${green}pass:${reset} did not compile: $code"
    fi
}
expect_pass() {
    code=$1
    if (echo "$code$end" | $intml -t -o /dev/null -); then
        echo "${green}pass:${reset} compiled: $code"
    else
        echo "${red}fail:${reset} did not compile: $code"
        failures=$(($failures + 1))
    fi
}


expect_fail "let x = 1 + ()"
expect_fail "let x = () + 1"
expect_fail "let x = () + ()"
expect_pass "let x = 1 + 1"
expect_pass "let x = () = ()"   # comparing units is allowed!
expect_fail "let x = () = 1"   # comparing ints and units is not!
expect_fail "let x = 1 = ()"   # comparing ints and units is not!

# if expressions
# both branches must have same type
expect_pass "let x = if 1 then 5 else 6"
expect_fail "let x = if 1 then () else 1"
expect_fail "let x = if 1 then 0 else ()"
# type of if is the type of one of the branches
expect_pass "let x = (if 1 then () else () : unit)"
expect_pass "let x = (if 1 then 1 else 1 : int)"
expect_fail "let x = (if 1 then () else () : int)"

# deduce the type of the parameter from the expression it's used in
expect_pass "let f x = x * 2"
# And iteratively allow that function to impose it's type on another
expect_pass "let f x = x * 49   let g x = f x"

# functions of two variables
expect_pass "let f x y = x + y"
# functions of three
expect_pass "let f x y z = x + y + z"

# ints are not functions
expect_fail "let f (x:int) = x x"
expect_fail "let y = 1 1"
# strings are not functions
expect_fail 'let y = "ho" "ho"'

# some fun with functions
expect_pass "let apply (f:int -> int) x = f x"
expect_pass "let fincr (f: unit -> int) = let g () = 1 + f () in g"
# and with some inference
expect_pass "let fincr f = let g () = 1 + f () in g"
expect_pass "let eq a b = a = b  let x = eq 1 2"
expect_fail 'let eq a b = a = b  let x = eq 1 "1"'

# Want to be able to infer the type of an earlier function from it's use
# 10:int && infer 10 => x = 10 in infer x = x => x:int
expect_pass "let infer x = x    let deduce = infer 10"

# ('a + ? => 'a:int) && f x = x => int = typeof(f x) = typeof(x)
expect_pass "let f x = x    let g y = f y + f y"

# lists
expect_pass "let x = [ 1; 2; 3 ]"
# lists should be of same type
expect_fail "let x = [ 1 ; () ]"
expect_fail "let x = [ () ; 2 ]"
expect_fail 'let x = [ "0" ; 1 ]'
expect_fail 'let x = [ 1 ; "2" ]'
# empty list conforms to type of any other list
expect_pass "let x = [1] = []"
expect_pass "let x = ([] : string list)"

# Vectors
expect_pass "let x = [| 1; 2; 3 |]"
# vectors should be of same type
expect_fail "let x = [| 1 ; () |]"
expect_fail "let x = [| () ; 2 |]"
expect_fail 'let x = [| "0" ; 1 |]'
expect_fail 'let x = [| 1 ; "2" |]'
# empty vector conforms to type of any other list
expect_pass "let x = [| 1 |] = [| |]"
expect_pass "let x = ([| |] : string vector)"

#cannot compare lists with vectors
expect_fail "let x = [] = [||]"
expect_fail "let x = [ 1 ] = [| 1 |]"

#pattern matching
expect_fail "let x :: y = []";
expect_pass "let x :: y = [ 1 ]";
expect_pass "let x :: y = [ 1 ; 2 ]";

# type aliases
expect_pass "type metre = int   let f (w:metre) (h:metre) = w * h / 2"
expect_pass "type intfunc = int -> int  let apply (f:intfunc) x = f x"

if [[ $failures == 1 ]]; then
    echo 1 failure
else
    echo $failures failures
fi

